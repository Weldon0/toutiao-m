<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
<script>
  /**
   * 明天的任务：
   * 1、好客租房登录界面 + 个人中心 + tab页面
   * 2、promise今天的讲的东西（后天提问）
   * 3、token作用（后天提问）
   * 4、vuex的作用（后天提问）
   */

  // 概念是什么？
  // 解决了什么问题？
  // 怎么解决的？
  // 项目怎么使用的？

  // 状态？三个 >> pending >> rejected >> resolved
  // 状态只能流转一次

  Promise.all([]).then(res => {}, err => {})


  // promise: 是一个异步解决方案
  // vuex：是vue.js状态管理工具
  //  怎么管理状态：集中管理所有组件状态
  //  解决跨组件传值
  //  组件直接和仓库通信，

  // state muttaions actions gettters modules

  //  vuex：所有组件都要用的属性存储vuex、用户信息、token
  /**
   *  静态方法：类或者构造函数自身的方法(只能通过类或者构造函数去访问)
   *  1、链式调用 >> 下一次then的执行取决于上一次then执行之后返回的结果(代码内部是否出错)
   *     catch和then一样，只不过没有第一个成功的回调
   *     如果all方法里面是接口请求，如果有一个报错了，其余的都会继续请求完成
   *     我们在代码能不能获取到成功的结果
   *  2、all >> 所有的promise成功之后才走成功,成功的结果组成的数组列表 >> 按照顺序组织
   *  3、race >> 以最快的作为结果
   *  4、allSettled >> 无论成功或者失败都可以获取到结果
   */

  // 账号:hzhmqd密码:123456
  // const a = new Promise((resolve, reject) => {
  //   setTimeout(() => {
  //     resolve("正确了");
  //   }, 1000);
  // });
  //
  // a.then(v => v, err => {
  //   console.log(err);
  // }).then(res => {
  //   console.log(res);
  // })

  // a.then(res => {
  //   console.log(res);
  // }, err => {
  //   console.log("promise error");
  //   // return Promise.reject('失败了')
  // }).then(null, err => {
  //   console.log(err);
  // })


  // v => v
  // a.then(null, err => {
  //   throw err
  // }).catch(err => {
  //   console.log("catch error"); // 会走 不会走
  //   console.log(err);
  // });

  //   链式调用 >> 下一次then的执行取决于上一次then执行之后返回的结果(代码内部是否出错)


  const a = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("正确了1");
    }, 1000);
  });

  const b = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("正确了2");
    }, 1000);
  });

  const c = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("正确了3");
    }, 1000);
  });

  Promise.all([a, b, c, 1, Promise.resolve(1)]).then(res => {
    console.log(res); // ? 每一个promise成功的值，并且按照传入的顺序组织的
  }, err => {
    console.log(err);
  })



  Promise.allSettled([a, b, c, Promise.reject('end')]).then(res => {
    console.log(res);
  })





</script>
</body>
</html>
